var fs = require('fs');


/*
*/


var sqlite3;
try {
    sqlite3 = require('sqlite3');
} catch (err) {
    sqlite3 = null;
}

var mysql;
try {
    mysql = require('mysql');
} catch (err) {
    mysql = null;
}

dbjuggle = {};

module.exports = dbjuggle;

dbjuggle.log = function (msg, sync) {
    if (sync) {
        fs.appendFileSync('dbjuggle.log', msg + '\n');
    } else {
        fs.appendFile('dbjuggle.log', msg + '\n');
    }
};

dbjuggle.DatabaseGeneric = function (dbcfg, dbspec) {
    this.dbcfg = dbcfg;
    this.dbspec = dbspec;
    this.pending = [];
    this.pending_lock = false;
    this.refcnt = 1;
    this.outstandingtrans = [];
    this.sql_error_is_fatal = dbcfg.sql_error_is_fatal || false;

    this.remoutstandingtrans = function (trans) {
        var ndx = this.outstandingtrans.indexOf(trans);
        if (ndx > - 1) {
            this.outstandingtrans.splice(ndx, 1);
        }
    }

    this.dup = function (cb) {
        dbjuggle.opendatabase(dbcfg, cb);
    }

    this.acquire = function () {
        ++this.refcnt;
    };

    this.release_all = function () {
        this.refcnt = 1;
        this.release();
    }

    this.release = function () {
        --this.refcnt;
        if (this.refcnt > 0) {
            /*
                Only release once the reference count
                has reached zero.
            */
            return;
        }
        /*
            Depending on the implementation this may cause
            the connection to be recycled back into a pool
            such as MySQL for an example; depending on the
            configuration specified.
        */
        this.dbspec.release(this);
        /*
            We need to render this object unsable. Hopefully
            the following code does the trick. That way if
            we forget we might be able to read a member of
            the object, but we surely will not be able to
            call any methods and corrupt/screw up the database
            connection incase it is recycled in a pool.
        */
        function __error_out() {
            throw new Error('You can not use a database connection after it has been released.');
        }

        for (var k in this) {
            if (typeof(this[k]) == 'function') {
                this[k] = __error_out;
            }
        }

        this.released = true;

        this.release = function () {
            dbjuggle.log('WARNING: double release on database');
        }

        --dbjuggle.opendatabase.outstanding;
        dbjuggle.log('dbjuggle.opendatabase.outstanding=' + dbjuggle.opendatabase.outstanding);
    };

    this.process_pending = function (clearlock) {
        if (clearlock) {
            // We have finished a transaction, and
            // we need to clear the lock and execute
            // any other pending transactions.
            this.pending_lock = false;
        }

        if (this.pending_lock) {
            console.log('dbjuggle executing next failed in middle of trans');
            // We are in the middle of executing
            // another transaction.
            return;
        }

        if (this.pending.length < 1) {
            // There is nothing left that
            // is current pending.
            console.log('dbjuggle executing next faile no next');
            return;
        }

        this.pending_lock = true;
        var next = this.pending.pop();
        console.log('dbjuggle executing next');
        next.__execute();
    };

    var self = this;

    this.transaction = function (safety_key_for_cont) {
        var r = {
            dbi:          self,
            stmts:        [],
            results:      {},
            done:         false,
            executed:     false,
            pending:      0,
            commited:     false,
            error_count:  0,
            cont:         safety_key_for_cont == 0x12345678 ? true : false, 
            deadtail:     null,
            notail:       false,

            transaction: function () {
                var ntrans = self.transaction(0x12345678);
                ntrans.deadtail = this;
                return ntrans;
            },
            locktable: function (table, writelock) {
                if (this.executed) {
                    throw new Error('This statement has already been executed');
                }
                this.dbi.dbspec.locktable(this, table, writelock);
            },
            add: function (sqlstmt, params, key) {
                if (this.executed) {
                    throw new Error('This statement has already been executed');
                }
                this.stmts.push({
                    sqlstmt:    sqlstmt,
                    params:     params,
                    resultkey:  key
                });
            },
            execute: function (cb, highpriority) {
                if (this.executed) {
                    throw new Error('This statement has already been executed');
                }

                // If we made a continuation then we can now be sure
                // in signaling to the tailing transaction that it should
                // not allow any commits or rollbacks.
                if (this.deadtail != null) {
                    console.log('set no tail for deadtail');
                    this.deadtail.notail = true;
                }

                // (1) Store the callback.
                // (2) Increment the database instance reference count.
                //     (We will release it once the callback returns)
                // (2) Add us to pending.
                // (3) Process the pending queue.
                this.executed = true;
                this.cb = cb;
                this.dbi.acquire();
                if (highpriority) {
                    /*
                        This is commonly used when we have taken some table
                        locks and need to do another operation with out releasing
                        these locks. So the transaction is entered as a high
                        priority which means it shall run next on this connection.
                    */
                    this.dbi.pending.splice(0, 0, this);
                } else {
                    this.dbi.pending.push(this);
                }
                this.dbi.process_pending(false);
            },
            __docb: function () {
                this.done = false;
                if (this.cb == true || this.cb == undefined) {
                    // If no callback specified, OR the callback
                    // was set to true, then auto-commit the
                    // transaction.
                    var r = this.commit();
                    this.dbi.release();
                    return r;
                }
                var r;
                try {
                    if (this.cb) {
                        r = this.cb(this);
                    } else {
                        console.log('no callback to call');
                    }
                } catch (err) {
                    /*
                        We do not want to handle the error
                        here, but we would like to decrement
                        the reference count we incremented
                        when this transaction was scheduled
                        for execution.
                    */
                    dbjuggle.log('WARNING: database execution callback error; decrementing reference', err);
                    this.dbi.release();
                    throw err;
                }
                // By default commit if we had no callback and a commit
                // or rollback has not already been done.
                if (!this.cb && !this.done) {
                    this.commit();
                }
                // By default rollback if we have called a callback, but
                // it did not do a commit or rollback.
                if (this.cb && !this.done) {
                    this.rollback();
                }
                this.dbi.release();
                return this.commited;
            },
            __execute: function () {
                var self = this;
                this.dbi.dbspec.transaction(this, null, function () {
                    self.pending = self.stmts.length;
                    for (var x = 0; x < self.stmts.length; ++x) {
                        var stmt = self.stmts[x];
                        // I have opted to using ? provided by sqlite3,
                        // and will just emulate that for any other
                        // database.
                        //
                        //if (stmt.params != undefined) {
                        //    for (var k in stmt.params) {
                        //        var re = new RegExp('{' + k + '}', 'g');
                        //        stmt = stmt.replace(re);
                        //    }
                        //}
                        self.dbi.dbspec.execute(self, stmt.sqlstmt, stmt.params, {
                            f: function (data, err, rows) {
                                // Only store results if we have a key to do so with.
                                if (data) {
                                    self.results[data] = {
                                        err:    err,
                                        rows:   rows ? rows : [],
                                    };
                                }
                                // Keep running count of errors.
                                if (err) {
                                    self.error_count += 1;
                                }
                                --self.pending;
                                // If we are done then execute our callback.
                                if (self.pending < 1) {
                                    self.__docb();
                                }
                            },
                            data: self.stmts[x].resultkey
                        });
                    }

                    if (self.pending == 0) {
                        self.__docb();
                    }
                });
            },
            rollback: function (cb) {
                if (this.done) {
                    return false;
                }
                var self = this;
                this.done = true;
                this.dbi.remoutstandingtrans(this);

                function __finish(cb) {
                  self.commited = false;
                  
                  if (!self.dbi.released) {
                    self.dbi.process_pending(true);
                  }

                  if (cb) {
                    cb(err);          
                  }
                }

                if (this.notail) {
                    console.log('no tail for rollback');
                    __finish(null);
                    if (cb) {
                        cb('This transaction was continued.');
                    }
                    return;
                }

                this.dbi.dbspec.rollback(this, function (err) {
                    __finish(cb);
                });
            },
            commit: function(cb) {               
                if (this.done) {
                    return false;
                }
                var self = this;
                this.done = true;
                this.dbi.remoutstandingtrans(this);

                function __finish(cb) {
                  self.commited = true;

                  if (!self.dbi.released) {
                    self.dbi.process_pending(true);
                  }

                  if (cb) {
                    cb(err);
                  }
                }

                if (this.notail) {
                    console.log('no tail for rollback');
                    __finish(null);
                    if (cb) {
                        cb('This transaction was continued.');
                    }
                    return;
                }

                this.dbi.dbspec.commit(this, function (err) {
                    __finish(cb);
                });
            },
        };

        self.outstandingtrans.push(r);
        return r;
    };

    return this;
}

dbjuggle.opendatabase = function (db, cb) {
    switch (db.type) {
        case 'mysql':
            if (mysql == null) {
                throw new Error('The `mysql` node module could not be loaded. Is it installed? `npm install mysql`');
            }
            var dbi = new dbjuggle.DatabaseGeneric(
                db,
                {
                    release: function (self) {
                        if (!self.done) {
                            /*
                                There is an on-going transaction, and there
                                was never a specified commit or rollback, so
                                let us be safe and just issue a rollback.
                            */
                            self.instance.query('ROLLBACK');
                            self.done = true;
                        }
                        self.instance.release();
                        self.instance = undefined;
                    },
                    locktable: function (self, name, writelock) {
                        self.__mysql_ttl = self.__mysql_ttl || [];
                        self.__mysql_ttl.push({
                            name:         name,
                            writelock:    (writelock ? true : false)
                        });
                    },
                    reconn: function (self, cb) {
                        dbjuggle.opendatabase.mysql_pools[self.dbi.dbid].getConnection(function (err, connection) {
                            self.dbi.instance = connection;
                            cb(err);
                            dbi.release();
                        });                        
                    },
                    execute: function (self, stmt, params, cb) {
                        try {
                            self.dbi.instance.query(stmt, params, function (error, results, fields) {
                                if (error) {
                                    dbjuggle.log('SQL error', true);
                                    dbjuggle.log(error, true);
                                    dbjuggle.log(stmt, true);
                                    dbjuggle.log(params, true);
                                    /*
                                        (see below for note about rollback)
                                    */
                                    self.rollback();
                                    
                                    // Attempt to reconnect on fatal error.
                                    if (error.fatal) {
                                        self.dbi.reconn(function (err) {
                                            if (self.dbi.sql_error_is_fatal) {
                                                throw new Error('SQL statement error.');
                                            }
                                        });
                                    }                     
                                    
                                    if (self.dbi.sql_error_is_fatal) {
                                        throw new Error('SQL statement error.');
                                    }
                                }
                                cb.f(cb.data, error, results);
                            });
                            //dbjuggle.log(stmt, params);
                        } catch (err) {
                            if (self.dbi.sql_error_is_fatal) { 
                                dbjuggle.log('SQL error');
                                dbjuggle.log(err);
                                dbjuggle.log(stmt);
                                dbjuggle.log(params);
                                dbjuggle.log(cb);
                            }
                            /*
                                Rollback the transaction, because this can be caught
                                and the application may reuse the connection for another
                                transaction and we do not want this accidentally commited.
                            */
                            self.rollback();
                            throw err;
                        }
                    },
                    transaction: function (self, data, cb) {
                        // We shall just make sure that the default is enabled and
                        // use a transaction to turn off the auto-commit.
                        //
                        // If this is a marked continuation, then we are continuing an
                        // currently open transaction.
                        if (!self.cont) {
                            self.dbi.instance.query('SET autocommit=1');
                            self.dbi.instance.query('START TRANSACTION');
                            if (self.__mysql_ttl != undefined && self.__mysql_ttl.length > 0) {
                                var parts = []
                                for (var x = 0; x < self.__mysql_ttl.length; ++x) {
                                    parts.push(self.__mysql_ttl[x].name + (self.__mysql_ttl[x].writelock ? ' WRITE' : 'READ'));
                                }
                                self.dbi.instance.query('LOCK TABLES ' + parts.join(', '));
                            }
                        }
                        cb(data);
                    },
                    rollback: function (self, cb) {
                        self.dbi.instance.rollback(cb);
                        if (self.__mysql_ttl != undefined && self.__mysql_ttl.length > 0) {
                            self.dbi.instance.query('UNLOCK TABLES');
                        }
                    },
                    commit: function (self, cb) {
                        self.dbi.instance.commit(cb);
                        if (self.__mysql_ttl != undefined && self.__mysql_ttl.length > 0) {
                            self.dbi.instance.query('UNLOCK TABLES');
                        }
                    }
                }
            );
            dbi.db = db;
            /*
                Here I create a pool for each unique database that we will
                connect to. This prevents us from overloading the database
                with too many connections, while still providing as many as
                possible for hungry clients. The MySQL module happened to
                have the pooling built-in so I decided to use what it provided.
            */
            dbjuggle.opendatabase.mysql_pools = dbjuggle.opendatabase.mysql_pools || {};
            /*
               TODO:    make this support more friendly and safe.. get rid of \x06
               WARNING: potential problem
            */
            var dbid = db.host + '\x06' + db.user + '\x06' + db.dbname;
            if (!dbjuggle.opendatabase.mysql_pools[dbid]) {
                dbjuggle.log('created mysql connection pool for ' + db.host + ':' + db.user + ':' + db.dbname);
                dbjuggle.opendatabase.mysql_pools[dbid] = mysql.createPool({
                    host:     db.host,
                    user:     db.user,
                    password: db.pass,
                    database: db.dbname
                });
            }

            dbi.dbid = dbid;
            dbjuggle.opendatabase.mysql_pools[dbid].getConnection(function (err, connection) {
                dbi.instance = connection;
                if (dbjuggle.opendatabase.outstanding == undefined) {
                    dbjuggle.opendatabase.outstanding = 0;
                }
                ++dbjuggle.opendatabase.outstanding;
                dbjuggle.log('got mysql connection for ' + db.host + ':' + db.user + ':' + db.dbname);
                cb(err, dbi);
                dbi.release();
            });
            /*
                This is the old method when not using a pool.
                dbi.instance.connect();
            */
            return;
        case 'sqlite3':
            if (sqlite3 == null) {
                throw new Error('The `sqlite3` node module could not be loaded. Is it installed? `npm install sqlite3`');
            }
            throw new Error('SQLITE3 not fully implemented');
            var dbi = new dbjuggle.DatabaseGeneric(
                db,
                {
                    locktable: function (self, name) {
                        self.__sqlite3_begin = 'BEGIN EXCLUSIVE TRANSACTION';
                    },
                    execute: function (self, stmt, params, cb) {
                        self.dbi.instance.all(stmt, params, function (err, rows) {
                            cb.f(cb.data, err, rows);
                        });
                    },
                    transaction: function (self, data, cb) {
                        self.dbi.instance.serialize(function () {
                            if (self.__sqlite3_begin) {
                                self.dbi.instance.run(self.__sqlite3_begin);
                            } else {
                                self.dbi.instance.run('BEGIN TRANSACTION');
                            }
                            cb(data);
                        });
                    },
                    rollback: function (self) {
                        self.dbi.instance.run('ROLLBACK');
                    },
                    commit: function (self) {
                        self.dbi.instance.run('COMMIT');
                    }

                }
            );

            //cb(null, new sqlite3.Database(db.path));
            throw new Error('SQLITE3 MISSING SMALL STUB IMPLEMENTATION');
        default:
            throw new Error('The database type was not supported.');
    }
}
