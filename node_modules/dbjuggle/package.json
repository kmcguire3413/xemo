{
  "name": "dbjuggle",
  "version": "0.0.5",
  "description": "Provides support or framework for various databases with connection pooling if supported and automatic release of connections across asynchronous calls.",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/kmcguire3413/dbjuggle"
  },
  "keywords": [
    "transaction",
    "sql",
    "sqlite",
    "database",
    "mysql",
    "pool"
  ],
  "author": {
    "name": "Leonard Kevin McGuire Jr",
    "email": "kmcg3413@gmail.com",
    "url": "http://kmcg3413.net/"
  },
  "license": "APACHE LICENSE",
  "bugs": {
    "url": "https://github.com/kmcguire3413/dbjuggle/issues"
  },
  "homepage": "https://github.com/kmcguire3413/dbjuggle",
  "readme": "DbJuggle\r\n==========\r\n\r\nA small library that provides connection pooling, acquisition, and release for\r\ndatabases that support or can emulate transactions. It makes managing a connection\r\npool easier and the release of connections.\r\n\r\n_It does not provide SQL compatibility between databases._\r\n\r\n## Notes\r\n\t\r\nI only need to add a small stub for sqlite3 to complete support. Also, this module\r\nis very new and may contain bugs.\r\n\r\n## Built-In Database Support\r\n\r\n\tMySQL - working\r\n\tsqlite3 - disabled \r\n\t          (working, but missing some release code)\r\n\r\n## Installation\r\n\r\n\tnpm install dbjuggle\r\n\r\n## Usage\r\n\r\n\tconst dbjuggle = require('dbjuggle');\r\n\r\n\tdbjuggle.opendatabase({\r\n        type:     'mysql',\r\n        host:     'localhost',\r\n        dbname:   'mydatabase',\r\n        user:     'myuser',\r\n        pass:     'mypassword'\r\n\t}, function (err, dbconn) {\r\n\t\tvar trans = dbconn.transaction();\r\n\t\ttrans.add(\r\n\t\t\t'SELECT id, name, age FROM personnel WHERE id > ? AND age > ?', \r\n\t\t\t[10, 20], \r\n\t\t\t'keya'\r\n\t\t);\r\n\t\ttrans.add(\r\n\t\t\t'SELECT name FROM books WHERE author = ?', \r\n\t\t\t['Somebody'], \r\n\t\t\t'whatever'\r\n\t\t);\r\n\t\t/*\r\n\t\t\tThis will increment the reference count for the connection.\r\n\r\n\t\t\tThe call is nested between a try and catch block to help decrement the \r\n\t\t\treference count if an error occures.\r\n\t\t*/\r\n\t\ttrans.execute(function (trans_ref_copy) {\r\n\t\t\tif (trans_ref_copy.results.keya.err || trans_ref_copy.results.whatever.err) {\r\n\t\t\t\t/* The transactions encountered an error. */\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar keya = trans_ref_copy.results.keya.rows;\r\n\t\t\tvar whatever = trans_ref_copy.results.whatever.rows;\r\n\r\n\t\t\tfor (var x = 0; x < keya.length; ++x) {\r\n\t\t\t\tvar id = keya[x].id;\r\n\t\t\t\tvar name = keya[x].name;\r\n\t\t\t\tvar age = keya[x].age;\r\n\t\t\t}\r\n\t\t\tvar another_trans = dbconn.transaction();\r\n\t\t\t/*\r\n\t\t\t\t.... make another transaction ...\r\n\r\n\t\t\t\tThis transaction will actually execute after our current\r\n\t\t\t\ttransaction finishes since they are on the same connection.\r\n\r\n\t\t\t\tIf you would like to get a transaction that will run right now \r\n\t\t\t\tor as soon as possible then grab another database connection \r\n\t\t\t\tlike below.\r\n\t\t\t*/\r\n\t\t\tdbconn.dup(function (err, anotherconn) {\r\n\t\t\t\t/*\r\n\t\t\t\t\tThis execution may be delayed if no connection exists in\r\n\t\t\t\t\tthe pool and depending on the implementation of the \r\n\t\t\t\t\tspecific database.\r\n\t\t\t\t*/\r\n\t\t\t\tvar trans_on_another_conn = anotherconn.transaction();\r\n\t\t\t});\r\n\r\n\r\n\t\t\t/*\r\n\t\t\t\tWe might like to commit or rollback?\r\n\r\n\t\t\t\tA rollback automatically happens when the callback exits, unless\r\n\t\t\t\tyou called commit, or a commit happens if you provided no callback.\r\n\t\t\t*/\r\n\t\t\tif (something) {\r\n\t\t\t\ttrans_ref_copy.commit();\r\n\t\t\t} else {\r\n\t\t\t\ttrans_ref_copy.rollback();\r\n\t\t\t}\r\n\r\n\t\t\t/*\r\n\t\t\t\tThis is the only tricky place. If you call something that \r\n\t\t\t\tbecomes asynchronous and it holds a reference to `dbconn` \r\n\t\t\t\tthen it may throw an error because once `dbconn` has been \r\n\t\t\t\treleased all methods throw errors. This is beneficial but can\r\n\t\t\t\tcause errors so BEWARE, luckily at least you will know...\r\n\t\t\t\t.. eventually.\r\n\t\t\t*/\r\n\t\t\tdbconn.acquire();\r\n\t\t\tmy_other_function_with_an_async_callback(function () {\r\n\t\t\t\t/* Notice that we called `dbconn.acquire` above.\r\n\t\t\t\tdbconn.transaction();\r\n\t\t\t\t/* Notice we have to do a manual release call here. */\r\n\t\t\t\tdbconn.release();\r\n\t\t\t});\r\n\r\n\t\t\t/* \r\n\t\t\t\tThe connection reference count is decremented when this \r\n\t\t\t\tfunction exits, and if the reference count is zero then it is \r\n\t\t\t\treleased back to the pool if a pool is implemented and \r\n\t\t\t\tsupported.\r\n\t\t\t*/\t\t\t\r\n\t\t});\r\n\t\t/*\r\n\t\t\tIf reference count is zero the connection would be released here.\r\n\t\t\tBut... its not going to be if we called trans.execute above.\r\n\t\t*/\r\n\t});\r\n\r\n## Domains\r\n\r\nYou may wish to wrap your code using the `domain` module, see `require('domain')` which can\r\nprovide the ability to release the connection using `dbconn.release_all()` which will decrement\r\nthe reference count to zero and make the reference to the connection unusable. Although the\r\nactualy connection will be recycled and placed back into the pool (if pools are supported).",
  "readmeFilename": "README.md",
  "gitHead": "ca982caf9d834f79a0591bf198360da373619092",
  "_id": "dbjuggle@0.0.5",
  "_shasum": "02276fe0b66a68dfea5f2062f4cfda8c918f3c51",
  "_from": "dbjuggle@"
}
